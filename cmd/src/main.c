#include "log.h"
#include "options.h"
#include "timer.h"
#include "version.h"

#include <iuab/compiler.h>
#include <iuab/vm.h>
#include <iuab/version.h>

#include <unistd.h> /* for optind */

#include <errno.h>
#include <string.h> /* for strerror */
#include <stdlib.h> /* for malloc, free, size_t, EXIT_SUCCESS, EXIT_FAILURE */
#include <stdint.h> /* for uint8_t */
#include <stdio.h>  /* for printf, fprintf, fclose, fopen, FILE */

void log_compiler_error(struct iuab_compiler *comp) {
    if (comp->error == IUAB_ERROR_DEPTHNZ) {
        log_error("%s", iuab_strerror(comp->error));
    } else {
        log_error("%s at line %lu, col %lu", iuab_strerror(comp->error),
            comp->token.line, comp->token.col);
    }
}

int compile_program(FILE *src, uint8_t **dest, size_t *len) {
    struct iuab_compiler *comp = malloc(sizeof(struct iuab_compiler));

    if (!comp) {
        log_error("memory allocation failure");
        return EXIT_FAILURE;
    }

    enum iuab_error result = iuab_compiler_init(comp, src);

    if (result != IUAB_ERROR_SUCCESS) {
        log_error("%s", iuab_strerror(result));
        free(comp);
        return EXIT_FAILURE;
    }

    timer_start();
    iuab_compiler_run(comp, dest);
    timer_stop("compiled in");

    fclose(src);

    if (comp->error != IUAB_ERROR_SUCCESS) {
        log_compiler_error(comp);
        iuab_compiler_free(comp);
        return EXIT_FAILURE;
    }

    *len = comp->output->len;
    iuab_compiler_free(comp);
    return EXIT_SUCCESS;
}

void print_bytecode(const uint8_t *code, size_t len) {
    size_t i = 0;

    while (i < len) {
        uint8_t op = code[i];
        printf("[0x%0*zX] %-5s", 2 * (int) sizeof(size_t), i, iuab_op_name(op));
        i++;

        /* Print the operand if there is one */
        if (op >= IUAB_OP_INCP && op <= IUAB_OP_DECV) {
            printf(" 0x%X", code[i++]);
        } else if (op == IUAB_OP_JMPZ || op == IUAB_OP_JMPNZ) {
            printf(" 0x%zX", *((size_t *) &code[i]));
            i += sizeof(size_t);
        }

        putchar('\n');
    }
}

enum iuab_error execute_program(const uint8_t *program) {
    struct iuab_vm *vm = malloc(sizeof(struct iuab_vm));

    if (!vm) {
        log_error("memory allocation failure");
        return EXIT_FAILURE;
    }

    iuab_vm_init(vm, program, stdin, stdout);
    size_t last_op_pos;

    timer_start();
    enum iuab_error result = iuab_vm_run(vm, &last_op_pos);
    timer_stop("executed in");

    free(vm);

    if (result != IUAB_ERROR_SUCCESS) {
        log_error("%s at 0x%X", iuab_strerror(result), last_op_pos);
        return EXIT_FAILURE;
    }

    return EXIT_SUCCESS;
}

int interpret(FILE *file, struct options *opts) {
    log_info("compiling...");
    uint8_t *code;
    size_t len;
    int result = compile_program(file, &code, &len);

    if (result != EXIT_SUCCESS) {
        return result;
    }

    if (opts->verbosity > 1) {
        log_info("generated bytecode:");
        print_bytecode(code, len);
    }

    log_info("executing...");
    result = execute_program(code);
    free(code);
    return result;
}

void print_usage(const char *name, FILE *dest) {
    fprintf(dest, "usage: %s [options] [file] [options]\n\
\n\
options:\n\
    -h      print this help message then exit\n\
    -v      increase the verbosity level\n\
    -V      print version info then exit\n\
", name);
}

void print_version() {
    printf("i-use-arch-btw %s\n", INTERPRETER_VERSION);
    printf("libiuab %s\n", IUAB_VERSION_STRING);
}

int main(int argc, char **argv) {
    struct options opts;

    if (options_init(&opts, argc, argv) || opts.help) {
        print_usage(argv[0], opts.help ? stdout : stderr);
        return !opts.help;
    }

    if (opts.verbosity > 0) {
        log_set_level(LOG_LEVEL_INFO);
    }

    if (opts.version) {
        print_version();
        return EXIT_SUCCESS;
    }

    /* Main mode/routine: interpret input source file */

    if (optind >= argc) {
        print_usage(argv[0], stderr);
        return EXIT_FAILURE;
    }

    FILE *src = fopen(argv[optind], "rb");

    if (!src) {
        log_error("could not open file: %s", strerror(errno));
        return EXIT_FAILURE;
    }

    return interpret(src, &opts);
}
